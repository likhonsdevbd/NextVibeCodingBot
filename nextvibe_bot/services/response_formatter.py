"""
Response formatter for creating user-friendly responses
"""

import logging
from typing import Dict, Any, Optional
from datetime import datetime
import re

from ..config import settings


logger = logging.getLogger(__name__)


class ResponseFormatter:
    """Format analysis results for user display"""
    
    def __init__(self):
        self.max_message_length = 4000  # Telegram message limit
        
    async def format_response(self, analysis: Dict[str, Any]) -> str:
        """
        Format analysis results into a user-friendly response
        
        Args:
            analysis: Complete analysis results
            
        Returns:
            Formatted response string
        """
        logger.info("Formatting response")
        
        # Build response sections
        sections = []
        
        # Header
        sections.append(self._format_header(analysis))
        
        # Solution approach
        if "solution" in analysis:
            sections.append(self._format_solution(analysis["solution"]))
            
        # Code analysis
        if "code_analysis" in analysis and analysis["code_analysis"].get("blocks_analyzed", 0) > 0:
            sections.append(self._format_code_analysis(analysis["code_analysis"]))
            
        # Implementation plan
        if "implementation_plan" in analysis:
            sections.append(self._format_implementation_plan(analysis["implementation_plan"]))
            
        # Execution results
        if analysis.get("execution_result"):
            sections.append(self._format_execution_results(analysis["execution_result"]))
            
        # Footer
        sections.append(self._format_footer(analysis))
        
        # Combine all sections
        response = "\\n\\n".join(sections)
        
        # Truncate if too long
        if len(response) > self.max_message_length:
            response = self._truncate_response(response)
            
        return response
        
    def _format_header(self, analysis: Dict[str, Any]) -> str:
        """Format the response header"""
        
        status_emoji = {
            "completed": "âœ…",
            "error": "âŒ", 
            "analyzing": "ğŸ”„",
            "pending": "â³"
        }
        
        status = analysis.get("status", "pending")
        emoji = status_emoji.get(status, "ğŸ¤–")
        
        task_type = analysis.get("task_type", "coding")
        language = analysis.get("language", "auto-detect")
        
        header = f"{emoji} *Task Analysis Complete*\\n\\n"
        header += f"ğŸ“‹ **Type:** {task_type.title()}\\n"
        header += f"ğŸ’» **Language:** {language}\\n"
        header += f"ğŸ“Š **Confidence:** {analysis.get('confidence', 0):.0%}\\n"
        header += f"â° **Analyzed:** {datetime.fromisoformat(analysis['timestamp']).strftime('%H:%M:%S UTC')}"
        
        return header
        
    def _format_solution(self, solution: Dict[str, Any]) -> str:
        """Format the solution approach"""
        
        if not solution or not solution.get("approach"):
            return "ğŸ’¡ *Solution:* Analysis completed, check the implementation plan below."
            
        approach = solution["approach"]
        
        # Clean up the approach text
        approach = self._clean_markdown(approach)
        
        # Split into sections if too long
        if len(approach) > 1000:
            approach = approach[:1000] + "...\\n\\n*Note: Solution truncated for display*"
            
        solution_text = f"ğŸ’¡ *Solution Approach:*\\n\\n{approach}"
        
        # Add AI model info if available
        if solution.get("ai_model") and solution["ai_model"] != "fallback":
            solution_text += f"\\n\\nğŸ¤– *Generated by:* {solution['ai_model'].title()}"
            
        return solution_text
        
    def _format_code_analysis(self, code_analysis: Dict[str, Any]) -> str:
        """Format code analysis results"""
        
        if not code_analysis.get("blocks_analyzed", 0):
            return ""
            
        result = "ğŸ” *Code Analysis Results:*\\n\\n"
        result += f"ğŸ“ *Files analyzed:* {code_analysis['blocks_analyzed']}\\n"
        
        if code_analysis.get("quality_score", 100) < 100:
            result += f"ğŸ“ˆ *Quality score:* {code_analysis['quality_score']}/100\\n"
            
        if code_analysis.get("issues_found"):
            result += f"âš ï¸ *Issues found:*\\n"
            for issue in code_analysis["issues_found"][:5]:  # Limit to 5 issues
                result += f"  â€¢ {issue}\\n"
                
        if len(code_analysis.get("issues_found", [])) > 5:
            result += f"  *... and {len(code_analysis['issues_found']) - 5} more issues*\\n"
            
        return result
        
    def _format_implementation_plan(self, plan: list) -> str:
        """Format the implementation plan"""
        
        if not plan:
            return ""
            
        result = "ğŸ“‹ *Implementation Plan:*\\n\\n"
        
        for step in plan:
            result += f"{step}\\n"
            
        return result
        
    def _format_execution_results(self, execution: Dict[str, Any]) -> str:
        """Format execution results"""
        
        result = "âš¡ *Execution Results:*\\n\\n"
        
        status = execution.get("status", "pending")
        
        if status == "completed":
            result += "âœ… *Execution successful*\\n"
            result += f"â±ï¸ *Time taken:* {execution.get('execution_time', 0):.2f}s\\n"
            
            output = execution.get("output", "").strip()
            if output:
                # Truncate long output
                if len(output) > 500:
                    output = output[:500] + "\\n\\n... (output truncated)"
                    
                result += f"ğŸ“¤ *Output:*\\n```\\n{output}\\n```\\n"
                
        elif status == "failed":
            result += "âŒ *Execution failed*\\n"
            error = execution.get("error", "Unknown error")
            output = execution.get("output", "").strip()
            
            if error:
                result += f"ğŸš¨ *Error:* {error}\\n"
            if output:
                result += f"ğŸ“¤ *Output:*\\n```\\n{output}\\n```\\n"
                
        elif status == "skipped":
            result += "â­ï¸ *Execution skipped*\\n"
            result += f"â„¹ï¸ *Reason:* {execution.get('output', 'No executable code found')}\\n"
            
        elif status == "error":
            result += "ğŸ’¥ *Execution error*\\n"
            result += f"ğŸš¨ *Error:* {execution.get('error', 'Unknown error')}\\n"
            
        # Add files created
        if execution.get("files_created"):
            result += f"ğŸ“ *Files created:* {len(execution['files_created'])} file(s)\\n"
            
        return result
        
    def _format_footer(self, analysis: Dict[str, Any]) -> str:
        """Format the response footer"""
        
        footer = "\\n" + "â”€" * 50 + "\\n"
        footer += "ğŸ¤– *Need more help?*\\n"
        footer += "â€¢ Send me a follow-up question\\n"
        footer += "â€¢ Share more details about your issue\\n"
        footer += "â€¢ Ask me to explain any part of the solution\\n\\n"
        footer += f"ğŸ“ *Task ID:* `{analysis.get('task_id', 'N/A')}`"
        
        return footer
        
    def _clean_markdown(self, text: str) -> str:
        """Clean and normalize markdown text"""
        
        # Remove excessive markdown formatting
        text = re.sub(r'\*\*(.*?)\*\*', r'*\\1*', text)  # Convert ** to *
        text = re.sub(r'```(.*?)```', r'`\\1`', text, flags=re.DOTALL)  # Convert code blocks
        text = re.sub(r'\n{3,}', '\\n\\n', text)  # Remove excessive newlines
        text = re.sub(r' {2,}', ' ', text)  # Remove excessive spaces
        
        return text.strip()
        
    def _truncate_response(self, response: str) -> str:
        """Truncate response to fit within Telegram limits"""
        
        # Try to truncate at a sentence or paragraph boundary
        max_length = self.max_message_length - 100  # Leave room for truncation notice
        
        if len(response) <= max_length:
            return response
            
        # Find the last complete sentence within the limit
        truncated = response[:max_length]
        last_sentence = truncated.rfind('.')
        last_paragraph = truncated.rfind('\\n\\n')
        
        if last_paragraph > max_length * 0.8:
            cut_point = last_paragraph
        elif last_sentence > max_length * 0.8:
            cut_point = last_sentence + 1
        else:
            cut_point = max_length
            
        result = response[:cut_point].strip()
        result += "\\n\\n*... (response truncated due to length)*"
        
        return result